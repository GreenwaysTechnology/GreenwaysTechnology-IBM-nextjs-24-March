					Next js


Software Req:

1.Node.js
2.VSCODE
3.Docker

PreKnowledge:

1.Javascript
2.React fundamentals

What you are going to learn?

1.Next js
2.REST api developement
3.Database Programming Using Prisma ORM Framework
4.GraphQl with Apollo Framework
5.Connecting Graphql with Apollo Framework

.......................................................................................................
					Next js
.......................................................................................................

What is a Next?
	 Next is a flexible React framework that gives you building blocks to create fast "web applications".

What is React?
         React is javascript lib to build "Single Page Web applications"


What is web app?
  Type of distributed app,deployed at server , accessed over network(internet) vi various network protocals like http,tcp,smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Response would be document.
=>HTML

other responses types
XML,JSON,Documents,images,vidoes.........

What is web and why it was created?

  Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser,launched in 1992.


The first web server is NeXT computer

The first web page , lanuched http://info.cern.ch/hypertext/WWW/TheProject.html.


Types of Web application:

1.Static web applications - 1989 to 1995
    Hard coded html pages, Prepared html pages kept at server, the web server will send those html pages to clients - browsers
   Do you think Static web applications still exits?

 Yes!, but we dont prepare the html pages by hand.. rather we ask the server to prepare..



2.Dynamic Content generation application(1996 to till date)

  After 1995, many people thought that how we can use web for biz information system

 how to share biz informations via internet.
 Generally biz data is stored in databases , how to embed data base data into html pages

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients.

Web server core design to get client request and send html response to the client.

Along with web server, something was introduced called "Programming language runtime"


3.Web services-1998 to till date

 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and recive data because html is just user interface document language.

 We need , data to be exechanged, thats where new data model was created called 'XML'
xml based web apps called web services.

soap protocal was created to transfer XML based documents "SOAP based webservices"

After 2005 soap based web services, started failing due to mobile computing.

New Web services  were designed called "RestFull Web services"

Restfull web services were used to build any type of data formats like json,xml,pdf,html etc...

The first run time was created based on "c" language called "CGI-comman Gate way interface" later instead of c language "PERL" language.


4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using javascript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, Javascript.
Frameworks build based on SPA

1.Angular js
2.react
3.vue js
............................................................................................
				React as SPA lib
............................................................................................

Reactjs was created by facebook , in order to build SPA applications for browsers.


Advantages of SPA:
1.Pages are created  at client side, so server load is completly removed
2.SPA reduces the lot of phsyical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
.................

Pure client SPAs are problematic when the app is senstive to SEO and time-to concept
This is because the browser will recive a large empty HTML page and has to wait until the javascript is loaded before rendering any thing.

	    The brith of new Technology called  "SSR" -  Server Side Rendering
    ..................................................................................

I need SEO but at the same time, i want to use SPA as well.
We provides first class api to "render"  an SPA app into HTML strings on the server.

This allows server to send back already rendered HTML, allowing end users to see the content immediately while the javascript is being downloaded.

This process is called "hydration", the app is compiled at server side and sent to the client which will be  interactive.
............................................................................................
				Rendering Types
............................................................................................

What is Rendering?
   Render means preparation,HTML Page prepartion...

Rendering Types:
1.CSR- Client side Rendering.
   HTML Pages are prepared at client side - SPA Applications
2.SSR  -Server Side rendering
   HTML Pages are prepared at server side - Dynamic Content Generation applications.

Based on these rendering type, we can classify other rendering

1.Universal rendering /Hybrid Rendering
  Server + Client side , coimbing both rendering 

2.Full SSR and Partial SSR
    Partial SSR is nothing but only "index.html" is compiled at server , rest of the application is rendered at client side.
   Full SSR is nothing but "index.html" and other pages are compiled at server....
.............................................................................................
			When Rendering can happen
		     (when html pages are parepared)
.............................................................................................

1.Request time
2.Build time

1.Request time :
 When user types url 

  http://www.example.com/product--------------->Server Receives Request----Prepares Page--send   that page to client.

2.Build time
    Build is nothing but, preparing app for production.. before hosting we have to prepare the     app
  During build phase, we can prepare html pages/render html pages 

			SSG -  Static Site Generations

Building web sites/apps during build phase is called SSG.

Why SSG?
  Super fast page access

Based On SSG , There is specfication is available "JAM Stack"
...........................................................................................
			Drawback of SSG(JAMStack App)
..........................................................................................
If page has data, which is keep on changing, preparing a page "ahead of time", that causes problem. that means we cant generate page on demand...

Data changes rapidly , we need to enable request time page prepartion.
.........................................................................................................................................
			ISR - Incremental Static Rendenering
...........................................................................................

SSG - Build time or ahead of time
SSR - Request time

ISR = SSG + SSR - Build time + request time 
.............................................................................................

What is Nextjs?

  Next js is a framework that helps to build web apps of all types

 you can build Full SSR apps..
 you can build SSR With Request time
 you can build SSG with Build time -  JAMStacks
 you can build SSR with CSR  - Server + SPA - Hybrid rendering
 you can build rest apis also - Web services

Using Next you can build 
 Pure server side apps with database access, other external api access.....
..............................................................................................
		               Next js UI layer
.............................................................................................

Next js uses "react core features" to build UI layer...

React core features:
1.React compoent driven
2.React uses data mutation techniques like props and state
3.React uses event listeners for interactions
4.React hooks

Nextjs tech stack:

1.React as ui layer
2.Next does not recommend to use "redux"
3.Next uses api layer- rest api development
4.Next can talk to any database via orm frameworks...
..............................................................................................
			Next js Architecture:
.............................................................................................

Next js uses "Rust based build system" where as react uses web pack build ....

What is Rust?
 It is programming langugage, used to build Nextjs apps. Next core engine is written in Rust only.

Next.js Compiler:
..................
 Next js Compiler is written using RUST Using SWC (Speedy Web Compiler).

SWC allows next js to transform and minify the js code for production. This replaces babel.

SWC is 17x faster than Babel, it is embeded inside next js
...........................................................................................

....................................................................................
		NEXT JS Getting Started
.....................................................................................

How to install next js and how to create app?

System Req:

1.Node.js 16.8 or later
2.OS - any os
3.vs code.

How to create next js project?

G:\IBM\2024\March\Nextjs>npx create-next-app@latest
Need to install the following packages:
create-next-app@14.1.1
√ What is your project named? ... welcome-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\welcome-app.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- autoprefixer
- postcss
- tailwindcss


added 137 packages, and audited 138 packages in 27s

34 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Success! Created welcome-app at G:\IBM\2024\March\Nextjs\welcome-app


G:\IBM\2024\March\Nextjs>cd welcome-app

G:\IBM\2024\March\Nextjs\welcome-app>


Lanuch VS code:

G:\IBM\2024\March\Nextjs\welcome-app>code .
..............................................................................................
			 Lets Explore the Project Structure
..............................................................................................
package.json
{
  "name": "welcome-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.1.1"
  },
  "devDependencies": {
    "autoprefixer": "^10.0.1",
    "postcss": "^8",
    "tailwindcss": "^3.3.0"
  }
}


Scripts:
 dev :  Runs next js dev to start next.js app in development mode
 build : runs next build to build the app for production usage
 start: runs next start to start next app in production mode
 lint: runs next lint to  verify the app's code correct ness.


next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

 This files contains app configurations...

what is mjs?
    if you want to run "es 6  module" code on node js, which is not allowed by default.

if you want to run es 6 module code(export,import,export default)

Solution:
1.you have to convert es6 module code into commonjs , so that node can understand
2.you have to configure package.json 
   "type:module"
3.you have to save file with "fileName.mjs" extension.

Compiler Config:
................
jsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

tailwind css configuration:(css)

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
    },
  },
  plugins: [],
};

postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
...........................

public
 Stores static assets such as images,fonts,documents
 public dir are accessed inside code using the base URL "/"

src/app
  This is where all application code will go..

There are some ready made files are there.

layout.js
page.js
global.css

Note:
 Which is similar to index.js and App.js in react.
.............................................................................................

Start Next app:

:\IBM\2024\March\Nextjs\welcome-app>npm run dev

> welcome-app@0.1.0 dev
> next dev

   ▲ Next.js 14.1.1
   - Local:        http://localhost:3000

Attention: Next.js now collects completely anonymous telemetry regarding usage.
This information is used to shape Next.js' roadmap and prioritize features.
You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:
https://nextjs.org/telemetry

 ✓ Ready in 2.8s
 ○ Compiling / ...
 ✓ Compiled / in 3.2s (511 modules)
 ✓ Compiled in 290ms (241 modules)
 ○ Compiling /favicon.ico ...
 ✓ Compiled /favicon.ico in 1439ms (518 modules)
.............................................................................................
			  Next App is Conventional Over Configuration
..............................................................................................

                           "In Next every folder and files are predefined"


In Next there is no predefined index.html, because index.html is generated by Next js server during request time or build time.

File Names:
src/app
 1.page.js
 2.layout.js

 These files names are predefiend file names we cant change file names as we wish.

Files have been designed based on conventional over configuratotion, meaning ever file has meaning.

page.js
   It is holding user interface, if the page.js is part of "src/app" folder which is root file(index.html) called as landing page.

layout.js
   It is going to hold root layout,Which is required file.


           "Every Nextjs app must have this "src/app/layout.js" file

What is this files are all about?

 "React Components"

Page Component - page.js
Layout Component - layout.js
.............................................................................................
			 React core features inside next js
.............................................................................................
1.Component:
   In react every thing is component, in next also the component driven arch is followed.

2.Props
    In react data is passed to the component via props.

Types of Props:
1.Data as prop
2.State as Prop -Dynamic Prop
3.function as Prop- Listeners as Prop
4.Component as Prop

Component as Props syntax we use heavily.

Syntax : Component Rendering:
...........................

<Tab /> - Self closing 
   There is no child element

<Tab>
   <Grid/> - Component as Prop
</Tab>

const Tab = props=>{

  return <>
	{props.children}
  </>
}

Next:

<Layout>
	?   ---> <Page/> -- Index Page
</Layout>

.....................................................................................
			 Every thing is component is in Next.js
.....................................................................................

Page Component:
  It is place holder component which displays ui.

Layout Component:
  It is container component which holds Page Component

           layout - parent
	  ------------------------------
          |                             |
                      Page -child       |
          |                             |
          |                             |
          |                             |
           -------------------------------

How to declare compoents?

 1.every component must be "functional component" - No Class Component.
 2.every component must be exported using "export default" only.
 3.Every Next application must have "root layout" src/app/layout.js
 4.Every Next application must have  "home/landing page" src/app/page.js

src/app/page.js


export default function HomePage() {

      return <div>
          <h1>Home Page</h1>
      </div>

}

Root Layout:
src/app/
export default function RootLayout(props) {

  return <html lang="en">
    {/* Insert page */}
    <body>{props.children}</body>
  </html>

}

<RootLayout>
   <HomePage/>
</RootLayout>
.....................................................................................
			  File Conventions
......................................................................................
layout.js
  Shared UI for a segment(page/router) and its children
  if a layout.js presents inside src/app folder which is called root layout.
  if every next.js app must have one layout.js which is root layout file.

nestedlayout -layout.js
   Shared UI for a a segement and its children
  when you define routing, that time we may or not use layout...

root layout vs nested layout:
  root layout must have <html>,nested layout <div> or section elements

eg:

 <html>
  <head></head>
  <title>title</title> 
   <body>
	<nested Layout>Insert Page</nestedLayout>
   </body>
 </html>

page.js
  Unique UI of a route,meaning the page is mapped against routing like "/",index,products,users,customers

loading.js
  Loading UI (Spinner) for a segement and its children

not-found.js
   Not Found UI for a segment and for its children
   if routing is failed to map against a page, then next.js will show error page.

error.js
  It is used to show custom component logic errors.
Note:
  All error files are represented by "React Error Boundary".

global-error.js
  It is to show app level errors.

template:
  Specailzied re-rendered layout UI.

route.js
  you can write "restfull" web services".

default.js
  Fallback UI for "Parrel Routes"
 
Note:
 When we write next application, every thing is component
  Error is component
  Loading is Compoent
  Page is component
  Layout is compoent.

Since Everything is compoent , which forms component hierachy.

React dev tool can used to look into the component hiearchy....

Using react dev tool we can look , next application....

Component Structure/Hierarchy:
..............................

<Layout>
   <Template>
	<ErrorBoundary fallback={<Error/>}>
	   <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   </Template>	
</Layout>
....................................................................................
			   Routing
		       Pages and Layouts
....................................................................................

In Next js application routing is core concept, every thing is built on the top of routing only.

In Next js routing is in built.

The Skeleton of every next app is routing only.

Routing is mapped against folders and files only...

Inside the app directory, "folders" are used to define routes...

src/app/ ---- index route or home route.

http://localhost:3000/ ------->src/app/layout.js ---> page.js


Route Segment:

  Each folder represents a "route segment" that maps to a "URL" segement. in order to create route you can nest folders inside each other	

URL Pattern:

localhost:3000 /    
	       |
            Root segment

Segment means part of url.


localhost:3000 /     dashboard /settings
		|       |            |              
	Root segment  Segment   leaf Segment

How to create segments(eiether root/segement/leaf)?
  A special file called page.js to make route segments publicly accessible.

eg:

src/app/welcome/layout.js
// welcome page layout 

export default function WelcomeLayout({ children }) {
    return <div id="welcomelayout" style={{color:'red'}}>
        {children}
    </div>
}

src/app/welcome/page.js


export default function WelcomePage() {
    return <div>
        <h1>Welcome</h1>
    </div>
}

http://localhost/welcome

Nested Route:
src/app/welcome/hello/layout.js
export default function HelloLayout({ children }) {
    return <div id="hellolayout">
        {children}
    </div>
}
src/app/welcome/hello/page.js
export default function HelloPage(){
    return <>
        <h1>Hello Page</h1>
    </>
}

http://localhost:3000/welcome/hello
...................................................................................
			 Page Not found
..................................................................................
what if i have folder src/app/welcome/hai , but no page.js

http://localhost:3000/welcome/hai

You will get page not found, error

if no page.js found, then it will throw "404 Page Not Found" , that means next automatically fallback to "ErrorBoundary" , it maps against default notfound.js message.

What if i want custom NotFound Error page?

src/app/not-found.js

export default function NotFound() {
    return <h1>
        The Page you requested not available
    </h1>
}
....................................................................................
			    Public Access Route

if you have different name other than page.js , it will not be available for public access.

 app/settings/config.js

http://localhost:3000/settings/config - It will throw error.
....................................................................................
			  Pages and Other Components
....................................................................................

Layout is container, Page is mapped against route segement, which displays UI.

Can page hold other Components?

Yes

npx create-next-app@latest
Need to install the following packages:
create-next-app@14.1.2
Ok to proceed? (y) y
√ What is your project named? ... next-components
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*

			    Co-location

In addition to special files, you have the option to colocate your own files (e.g. components, styles, tests, etc) inside folders in the app or any route  directory.


co-located file:
src/app/welcome/Greet.jsx
//here you can use export or export default .

export default function Greet(props) {
     return <>
        <h1>{props.message}</h1>
     </>
}

src/app/welcome/page.js
import Greet from "./Greet";

export default function WelcomePage(){
    return <>
       <Greet message="Hello"/>
    </>
}

src/app/welcome/layout.js
export default function WelcomeLayout({ children }) {
    return <div>
        {children}
    </div>
}
.....................................................................................
			Component Types and Rendering Types
.....................................................................................

Rendering is nothing but page preparation (html creation).

How to create html and where to create Html?

Where:
 rendering can take place in the server or on the client.

When:
  At Server side:
  It can happen either ahead of time at build time.
  or on every Request at runtime.

With next js , three types of rendering methods are available.

1.Server-side rendering
   1.0. Request time
   1.1. Static site Generation - build time
   1.2. ISR - Incremental Static rendering - first Build time and later runtime.

2.Client Rendering
   Preparing portion of page at client side , which is similar to SPA Apps.

Component types:
 Based on Rendering, we can classify the component into two category.

1.Server Component
   Server components are rendered at server side
2.Client components
   Clients components are rendered at client side

  By default all components are "Server Rendered Components"

   page,layouts,templates,notfound,loading,default all are server components only

Even When create custom components

export default function Greet(props) {
     return <>
        <h1>{props.message}</h1>
     </>
}
.....................................................................................
			Client Component
....................................................................................

Generally React application is component driven....
Component which may have logic to interact with user like button clicks,typing,animations,data fetch at client side any dom manipulation......

The components can be co-located..

Client components allow us to write interactive UI that is prendered on the server and can use client javascript to run in the browser.

Advantages of client Rendering:

1.Interactivity
   Client components uses "state,effects,event listener" , meaning they can provide immediate feedback to the user and update the UI.

2.Browser APIs:
   Client components have access the browser apis like Storage,geo location....

How to create Client Component?

src/app/reviews/page.js
import Like from "./like";

export default function ReviewPage(){
    return <>
        <h1>Review Page</h1>
        <Like/>
    </>
}

src/app/reviews/like.jsx
import { useState } from "react"

export default function Like() {
    //declare state
    const [like, setLike] = useState(0)

    return <div>
        <h3>Like {like}</h3>
    </div>
}

After this code, next is throwing compile time error...

./src/app/reviews/like.jsx
Error: 
  × You're importing a component that needs useState. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.
  │ Learn more: https://nextjs.org/docs/getting-started/react-essentials
  │ 
  │ 
   ╭─[G:\IBM\2024\March\Nextjs\next-components\src\app\reviews\like.jsx:1:1]
 1 │ import { useState } from "react"
   ·          ────────
 2 │ 
 3 │ export default function Like() {
 3 │     //declare state
   ╰────

Why this error?
  Server not able to render the above code, the reason is the code is subject to browser rendering, means that server does not how to treat this code.
 in order to compile this code, we need to convert this component into client component...
 we need to use directive called "use client"

solution:
 'use client'
import { useState } from "react"

export default function Like() {
    //declare state
    const [like, setLike] = useState(0)

    return <div>
        <h3>Like {like}</h3>
    </div>
}

How to mutate the state?
 Similar to react code...
 
'use client'
import { useState } from "react"

export default function Like() {
    //declare state
    const [like, setLike] = useState(0)

    const onLike = () => {
        setLike(like + 1)
    }

    return <div>
        <h3>Like {like}</h3>
        <button onClick={onLike}>Like</button>
    </div>
}

How to know the client component?

if component has 

1.useState hook
2.Any listener
3.useEffect hook

....................................................................................
		Patterns for client and server components

1.Server component uses client component...

2.Client component uses another server component

3.Client component uses another client component

1.Server Component uses client component:
.........................................

server:

src/app/reviews/page.js
import Like from "./like";

export default function ReviewPage(){
    return <>
        <h1>Review Page</h1>
        <Like/>
    </>
}
client component
src/app/reviews/like.jsx
'use client'
import { useState } from "react"

export default function Like() {
    //declare state
    const [like, setLike] = useState(0)

    const onLike = () => {
        setLike(like + 1)
    }

    return <div>
        <h3>Like {like}</h3>
        <button onClick={onLike}>Like</button>
    </div>
}

Note:
 if server uses client, the component must be marked with "use client" directive..
...................................................................................

2.Client component uses another server component.

  if client uses another server component, Server Component automatically becomes client component.
 when we use this pattern, we loose server rendering...


}

server:
src/app/reviews/Dislike.jsx
export default function DislikeServer() {
      return <div>
       <h1>Dislike Server</h1>
    </div>
}

Client:
src/app/reviews/reviewClient.jsx
'use client'
import { useState } from "react"
import DislikeServer from "./Dislike"

export default function MyReview() {
    //declare state
    const [like, setLike] = useState(0)

    const onLike = () => {
        setLike(like + 1)
    }

    return <div>
        <h3>Like {like}</h3>
        <button onClick={onLike}>Like</button>
        {/* Use server component */}
        <DislikeServer/>
    </div>

In the code, DislikeServer component runs in the client only....

What if client uses server component but at the same time, i dont want to loose server rendering feature?

Solution:

 Pass Server component as prop to Child Component..

<Client>
    <Server/>
</Client>

src/app/client/myserver.jsx
export default function MyServer(){
    return <div>
        <h1>Server Component</h1>
    </div>
}
src/app/client/myclient.jsx
'use client'

// import MyServer from "./myserver"

export default function MyClient(props){
    return <div>
        <h1>Client component</h1>
        {/* <MyServer></MyServer> */}
        {props.children}
    </div>
}

src/app/client/page.js
import MyClient from "./myclient";
import MyServer from "./myserver";

export default function ClientPage() {
    return <>
        <h1>Client Page</h1>
        <MyClient>
            {/* sending server as prop  */}
            <MyServer/>
        </MyClient>
    </>
}
....................................................................................

3.Client Uses another client Component...

Client uses another client.

src/app/myreviews/page.js
import MyReview from "./MyReview";

export default function Likes(){
    return <div>
        MyReview Page
        <MyReview></MyReview>
    </div>
}

Client:

src/app/myreviews/MyReview.jsx

'use client'

import Like from "./like"

export default function MyReview() {
        return <>
        <Like></Like>
    </>
}
src/app/myreviews/like.jsx
// 'use client'
import { useState } from "react"

export default function Like() {
    //declare state
    const [like, setLike] = useState(0)

    const onLike = () => {
        setLike(like + 1)
    }

    return <div>
        <h3>Like {like}</h3>
        <button onClick={onLike}>Like</button>
    </div>
}

Note:
 if client component uses another client component, that another client component no need to use "use client" directive.
This would be very use full when we use third party ui components into next js...
primiarly used for migration...
....................................................................................
			Advanced Routing - Linking and Navigation
......................................................................................
>npx create-next-app@latest
√ What is your project named? ... linking-navigation
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\advanced-routing.


		...............Linking and Navigation.......


There are four ways to navigate between routes in Next.js

1.Using <Link> Component
2.Using useRouter Hook
3.redirect function
4.Using native History api

Reddirection/navigation can happen in two places

1.Server side redirection/navigation
   Redirection is controlled by server
2.Client side redirection/navigation
   Redirection is controlled by browser


Server side Navigation:
1.redirect function
2.permantRedirect function
3.routeConfig file
4.API redirections - NextResponse.redirect

Client Side Navigation:

1.Link Component
2.useRouter Hook
3.Native History API


Link Component:
 Link is in built Component from next, like Link Next many in built components

Built in Components:

1.Link
2.Image
3.Script
4.Font

Link:

1.Link is a built in component that extends the HTML <a> tag.
2.It enables client side navigation.
3.It enables prefetching feature...
4.It is part of "next/link" package

Link Props:

1.href - url
2.replace
3.scroll
4.prefetch

Syntax:
 href value can be string or object.

 <Link href="/about">About</Link>
 <Link href={{pathname:'/customer',query:{name:'ibm'}}}>About</Link>

Master Navigation:

 Navigation for full app.
 if you want to share nav bar , site footer, across the application, you have to write nav bar inside root layout.

src/app/layout.js
import { Inter } from "next/font/google";
import Link from "next/link";
// import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <div id="header">
          <h1>My Commerce</h1>
          <hr />
          <nav>
            <Link href={{ pathname: '/about' }}>About</Link> |
            <Link href={{ pathname: '/services' }}>Services</Link> |
            <Link href={{ pathname: '/' }}>Home</Link> |
          </nav>
        </div>
        {children}

        <hr />
        <div>
          <p>footer</p>
        </div>
      </body>
    </html>
  );
}
src/app/about/page.js


export default function AboutPage() {
    return <div>
        <h1>About Page</h1>
    </div>
}
src/app/services/page.js
export default function Services() {
    return <div>
        <h1>Service Page</h1>
    </div>
}
src/app/page.js


export default function HomePage() {
  return <div>
    <h1>Home Page</h1>
  </div>
}
.....................................................................................
				Active Links
.....................................................................................
How to enable active link feature?

You can use hook "usePathname()" to determine if a  link is active..
For example to add a class to the active link, you can check the current pathname matches the href of the link...

Syntax
import {usePathname} from 'next/navigation'

const pathname = usePathname()

<Link className={`link ${pathname==='/' ? 'active': ''}`} href="/">Home</Link>


if you add "usePathname", then that component must be client component..

Error: usePathname only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component


if you add inside root layout, you will get error, if you want active link feature, you want to include into server component(root layout/layout), you have to create separate link client component and include it.

src/app/components/link.css
.active {
    color: rgb(255, 0, 0);
}

src/app/components/links.jsx
'use client'
import { usePathname } from "next/navigation";
import Link from "next/link";
import './link.css'

export function Links() {
    const pathname = usePathname()
    return <nav>
        <ul>
            <li>
                <Link className={`link ${pathname === '/' ? 'active' : ''}`} href={{ pathname: '/' }}>Home</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/about' ? 'active' : ''}`} href={{ pathname: '/about' }}>About</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/services' ? 'active' : ''}`} href={{ pathname: '/services' }}>Services</Link>
            </li>
        </ul>
    </nav >
}
src/app/layout.js
import { Inter } from "next/font/google";
// import Link from "next/link";
import { Links } from "./components/links";
// import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <div id="header">
          <h1>My Commerce</h1>
          <hr />
          <Links />
        </div>
        {children}

        <hr />
        <div>
          <p>Footer</p>
        </div>
      </body>
    </html>
  );
}
.....................................................................................
				useRouter Hook
.....................................................................................

userRouter hook allows you programmatically change route from client components.

src/app/components/DashboardNavigator.jsx

'use client'
import { useRouter } from "next/navigation"

export function DashBoardNavigator() {
    const router = useRouter()
    return <>
        <button onClick={() => {
            router.push('/dashboard')
        }}>Dashboard</button>
    </>
}

src/app/page.js
import { DashBoardNavigator } from "./components/DashboardNavigator";


export default function HomePage() {
  return <div>
    <h1>Home Page</h1>
    <DashBoardNavigator/>
  </div>
}

src/app/components/links.jsx
'use client'
import { usePathname } from "next/navigation";
import Link from "next/link";
import './link.css'

export function Links() {
    const pathname = usePathname()
    return <nav>
        <ul>
           <li>
                <Link className={`link ${pathname === '/dashboard' ? 'active' : ''}`} href={{ pathname: '/dashboard' }}>Dashboard</Link>
            </li>
        </ul>
    </nav >
}
...................................................................................
			  Server side Navigation
...................................................................................

1.redirect api 
  The redirect function is the function allows you to redirect the user to another URL

Purpose:
 redirect after form submit
 redirect after a mutation or event...
Where:
  Server components,Server Actions, Route Handlers

Status code and redirect function:

307- Temp
303 - Server actions

Syntax:
export default function update(){
  //update logic
  redirect('success') //navigate to success page
}
Implementation will see later when we discuss server actions and api handlers...

2.permanentRedirect
  It is similar to redirect, but the status code would be 308

3.redirects in next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
    //redirct configuration
    async redirects() {
        return [
            {
                source: '/foo',
                destination: '/about',
                permanent: true
            }
        ]
    }
};

export default nextConfig;

4.NextResponse.redirect
   Inside Middleware
....................................................................................
			 Common concepts in navigation
...................................................................................

1.Prefetching:
.............

 pre-means in advance or ahead of time
 fetching - means getting or loading

Prefetching is way to preload a route in the background before the user visits it.

Lets assume i have menus like
 about,products,services,customers

if i click any menu, that time only page is fetched from the server (Server receives request--render page--return page to browser)

When you enable prefetch feature, the page is requested before user clicks the link for that particular page. - It is ready already..

How to enable prefetch feature?

<Link> Component:
   Routes are by default automatically prefetched as they become visible in the user's(browser's) view port. 
   Prefetching happens when the page first loads or when it comes into view through scrolling..
   Prefetching feature is not enabled in dev mode, only production mode.

Link 's Prefetch behaviour can be disabled by using property called prefetch=false

   <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>

prefetch has three values:

1.null /default
2.true
3.false

There are two types of route:

1.static route
    prefetch is true by default in static route
2.dynamic route
    prefetch is default to automatic/null

.....................................................................................
			Soft Navigation
.....................................................................................

Browsers perfom a hard navigation when navigating between pages.
The Next.js app router enables "soft navigation" between pages, ensuring only the route segments that have changed are re-rendered(partial rendering).
Soft Navigation helps or enables "react state" to be preserved during navigation.
.....................................................................................				Advance Routing-Dynamic routes
.....................................................................................

npx create-next-app@latest
√ What is your project named? ... dynamic-routes
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\dynamic-routes.

What is dynamic route?
  When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.

How to represent dynamic path?

  /users - static route
  /users/1 -dynamic route
  /users/100

How to create dynamic route?

Convention:
   A dynamic segment can be created by wrapping a folder's name in square brackets.
  [folderName]
   eg:
     [id] or [city] or [slug]

Use Case:
 Building Master detail page..

Using mock data
Using api call

Master Page with Mock Data:
...........................

src/app/todos/page.js
import { TODOS } from "./mock-data/todos"

export default function TodosMasterPage() {
    return <>
        <h1>Todos Master</h1>
        <ul>
            {
                TODOS.map(todo => {
                    return <li>
                        <span>{todo.title}</span>
                    </li>
                })
            }
        </ul>
    </>
}
Note: refer code base for mock data.

When i click the particular todo , i have to navigate to detail page.

Details Page:

src/app/todos/[id]/page.js


export default function TodosDetailPage(){
    return <>
        <h1>Todos detail page</h1>
    </>
}

Linking Master Page with Detail Page:

src/app/todos/page.js

import Link from "next/link"
import { TODOS } from "./mock-data/todos"

export default function TodosMasterPage() {
    return <>
        <h1>Todos Master</h1>
        <ul>
            {
                TODOS.map(todo => {
                    return <li>
                        <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                    </li>
                })
            }
        </ul>
    </>
}

How to read path Parameters?

Rout Parameters are available inside detail page via props.

props.params => {}

src/app/components/todos/[id]/page.js

// export default function TodosDetailPage(props) {
//     console.log(props)
//     return <>
//         <h1>Todos detail page</h1>
//         <h2>{props.params.id} details </h2>
//     </>
// }

export default function TodosDetailPage({params:{id}}) {
    //console.log(props)
    return <>
        <h1>Todos detail page</h1>
        <h2>{id} details </h2>
    </>
}
...................................................................................
		 Master details page Prepartion using API Calls
....................................................................................

In next js , api calls are made using "fetch" api by default.
fetch is promse powered, when ever or where ever you call fetch api, you can use async .. await keywords

server components functions, apis are marked as async keyword..

src/app/photos/page.js
import Link from "next/link"

//fetch photos
export async function fetchPhotos() {
    const response = await fetch('https://jsonplaceholder.typicode.com/photos')
    const photos = await response.json()
    //here we return Promise of Photos
    return photos
}

export default  async function PhotosMasterPage() {
    const photos = await fetchPhotos()
    return <>
        <h1>Photos Master</h1>
        <ul>
            {
                photos.map(photo => {
                    return <li>
                        <Link href={`/photos/${photo.id}`}>{photo.title}</Link>
                    </li>
                })
            }
        </ul>
    </>
}

src/app/photos/[id]/page.js
import Image from "next/image"

export async function fetchPhotoById(id) {
    const response = await fetch(`https://jsonplaceholder.typicode.com/photos/${id}`)
    const photo = await response.json()
    //here we return Promise of Photos
    return photo
}
export default async function PhotosDetailPage({ params: { id } }) {
    const photo = await fetchPhotoById(Number(id))
    return <>
        <h1>Photos  detail page</h1>
        <h2>Id {photo.id} </h2>
        <h2>Album Id {photo.albumId} </h2>
        <p>Title {photo.title}</p>
        <a href={`${photo.url}`}>{photo.url}</a>
        <Image
            src={`${photo.thumbnailUrl}`}
            width={500}
            height={500}
            alt="Picture of the Picture"
        /> 
    </>
}		

in order to display remote images, we need to  configure, next.config.mjs file

/** @type {import('next').NextConfig} */
const nextConfig = {
    images: {
        remotePatterns: [
            {
                protocol: 'https',
                hostname: 'via.placeholder.com',
                port: '',
                pathname: '/150/**',
            },
        ],
    },

};

export default nextConfig;
....................................................................................
			Advanced Routing-Dynamic routes
			 "Catch-All Segment Routing"
...................................................................................

Dynamic segments can be extended to catch all subsequent by adding [...slug]

Without CatchAll:
................

/shop/a 
/shop/b
/shop/c

shop
  |
  [a]
    |
    page.js
  |
  [b]
   |
    page.js
  [c]
   |
    page.js
 page.js

what if dynamic routes are not predefined in advance.

With Catch All:
................

 shop
  |
  page.js
  |
  [...slug]
    |
    page.js

/shop/tops
/shop/tops/tshirt
/shop/dress/men/shirt

How to capture parameter?
 {
   slug:['tops','tshirt','men','shirt']
 }


src/app/shop/page.js
export default function ShopPage() {
    return <>
        <h1>Shop Page</h1>
    </>
}

src/app/shop/[...slug]/page.js
export default function ShopDetailsPage({ params }) {
    return <>
        <h1>Shop Details Page</h1>
        <h2>{JSON.stringify(params)}</h2>
    </>
}
.....................................................................................
			 Advanced Routing-Dynamic Routes
		       "Optional Catch-All Segment Routing"
		
In the catch-All segement routing, the root folder has page.js, without that page.js what will happen>

src/app/shop/[...slug]/page.js

http://localhost:3000/shop
  ->It will throw page not found.

There would be use case , i dont want page.js inside /shop.

Thats where Optional CatchAll segment Routing comes picture..

src/app/shop/[[...slug]]
             |
     page.js

Eg:

src/app/shop/[[...slug]]/page.js
export default function ShopDetailsPage({ params }) {
    return <>
        <h1>Shop Details Page</h1>
        <h2>{JSON.stringify(params)}</h2>
    </>
}

Conclusion in dynamic routing:

 src/app/user/[id]- static dynamic routing
 src/app/shop/tops - dynamic catch all routing
 src/shop/
       page.js
 src/shop/[...slug]/page.js
 src/app/shop/[[...slug]/page.js -dynamic optional catch all routing
.....................................................................................
			Advanced Routing- Parallel Routes
.....................................................................................
What is Parallel route?
  Generally inside a layout, we render only one page by default.

What if i want to render "Multiple Pages" inside single layout simultaneously or conditionally.
 
"Parallel Routing allows you to simultaneously or conditionally render one or more pages in the same layout.
 For highly sections of an app, such as dashbords,and feeds on sites, Parallel Routing can be used to implement complex routing patterns"

Component View: Single Page witin layout.

<Layout>
   <Page/>
</Layout>

Component View: Mutliple Pages within layout

<Layout>
   <Page1/>
   <Page2>
</Layout>

Component View: Conditional Rendering

<Layout>
   {condition ? <ThisPage/> : <ThatPage/>
</Layout>

\IBM\2024\March\Nextjs>npx create-next-app@latest
Need to install the following packages:
create-next-app@14.1.3
Ok to proceed? (y) y
√ What is your project named? ... parralle-route
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\parralle-route.


Basic Structure:

 src/app
     |
     page.js
     layout.js
 info
    |
  page.js
  layout.js

Here only info page is inserted into info layout
now i want to display two pages called team and analytics within info layout


src/app/game/layout.js
export default function GameLayout(props) {
    return <div id="gameslayout">
         {props.children}
    </div>
}

src/app/game/page.js
export default function GamePage(){
    return <div>
        <h1>GamePage</h1>
    </div>
}

3.Parralel Routing,we need to create folder with following syntax

 @FolderName
   |
   layout.js
   page.js

src/app/game/@team/page.js

export default function TeamPage(){
    return <div>
        <h1>Team Page</h1>
    </div>
}

src/app/game/@anaylitics/page.js
export default function AnalyticsPage(){
    return <div>
        <h1>Analytics Page</h1>
    </div>
}

Now if you test 
http://localhost:3000/game/team
   The output would be pagenot found, the reason is you cant access team page publicily, team page is part of something, that means , you must inject into game layout.
 How to inject into game layout...
   via props


Insert team and anayltics page content into game layout.

src/app/game/layout.js
export default function GameLayout(props) {
    return <div id="gameslayout">
        {/* Game Page content */}
         {props.children}
         {/* Team Page */}
         {props.team}
         {/* Analytics Page */}
         {props.anaylitics}
    </div>
}
..................................................................................
				 Advanced Routing	
			Parrallel Routing - Conditional Rendering
....................................................................................
   
As of now we have seen how to render multiple pages into a layout.

Now we are going to discuss how to render page or pages into a layout based on condition.

Slot:
 Portion of UI.
 Slots are defined using named slots
 Slots are defined with @folder convention
 For eg @team,@player
 Slotss are passed as props to the shared parent layout.

We render a slot based UI based on certain conditions,such as checkbox, and options,authentication states...

Synax:

@AdminPanel
@UserPanel

src/app/panel/page.js
export default function PanelPage() {
    return <>
        <h1>Panel Page</h1>
    </>
}
src/app/panel/@AdminPanel/page.js
export default function AdminPanel(){
    return <>
      <h1>Admin Panel Page</h1>
    </>
}
src/app/panel/@UserPanel/page.js
export default function UserPanel(){
    return <>
      <h1>User Panel Page</h1>
    </>
}
src/app/panel/layout.js
export default function PanelLayout(props) {
    const isAdmin = true

    return <div id="panelLayout">
        {/* Panel Page */}
        {props.children}
        {/* Conditional Rendering */}
        {isAdmin ? props.AdminPanel : props.UserPanel}
    </div>
}
.....................................................................................	
			ParrelRouting -UnMatched Routing
.....................................................................................

default.js

 You can define default.js file to render as a fallback for unmatched slots during inital load or full page reload.

src/app/panel/@UserPanel/default.js
export default function UserFallback(){
    return <h1>Fallback UI</h1>
}
.....................................................................................
		      Advanced Routing - Route Groups
......................................................................................
What is Route Group?

In the app directory, nested folders are mapped to URL Paths. How ever, you can mark a folder as a Route Group to prevent the folder being inlcuded in the Route' URL Path..

src/app/dashboard/page.js   ==> /dashboard

You can mark a folder as a "Route Group" to prevent the folder being included in the rout's URL Path.

Which is some times called as hidden dirs...

Why Route Groups:

 =>Organize your route segments and project files into logical groups without affecting the URL path Structure.

=> Organizing routes into groups eg Site Section, intent, or team.

=> Enabling nested layout in the same route segment level.
    You can multiple root layouts in different segements


Convention:
  A Route group can be created by wrapping a folder's name in ()

eg:

 (folderName)

G:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... route-groups
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\route-groups.

Using npm.

src/app/(auth)/signin/page.js
export default function SignInPage(){
    return <>
        <h1>Sigin Page</h1>
    </>
}

src/app/(auth)/login/page.js
export default function loginPage(){
    return <>
        <h1>Login Page</h1>
    </>
}
.....................................................................................
			Advanced Routing - Route Groups
			      (Shared Layout)
....................................................................................

How to share common layout for all modules / domains/groups

src/app/layout.js

Eg: domains
 auth,marketing,products

src/app/(auth)/layout.js
export default function AuthLayout({children}){
    return <div id="authlayout">
           {children}
    </div>
}
.................................................................................
			Advanced Routing - Route Groups
			      (Specific Layout)
................................................................................

How to have a specific layout for a route?

src/(app)/login/layout.js
export default function AuthLayout({children}){
    return <div id="loginlayout">
           {children}
    </div>
}
.....................................................................................
.................................................................................
			Advanced Routing - Route Groups
			      (Multiple Layout)
................................................................................
if you need multiple root layouts,for eg i am building ecommerce app, where auth is separate domain, product separate domain...

If you need different layout inside each domain, we have to remove root layout file.

inside domain layout, you have to return html.


Steps:

1.just remove src/app/layout.js or rename.
2.add src/app/(auth)layout.js
// export default function AuthLayout({children}){
//     return <div id="authlayout">
//            {children}
//     </div>
// }

import { Inter } from "next/font/google";
// import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 		Advanced Routing- Route Intercepting
.....................................................................................

What is intercepting router?
  Intercepting routes allows you to load a route from another part of your application within the current layout.
 This routing paradigm can be useful when you want to display the content of a route without the user switching to a different context.

For ex, when clicking on a photo from within a feed, a modal overlaying the feed should show up with the photo.In this case, Next.js intecepts the feed route and "masks" this URL to show /photo/23 instead.

How ever, navigating to the photo by clicking a sharable URL or by the refreshing the page, the entire photo page should render instead of the modal. No route interception should occur.

Convention:
 Intecetping routes can be defined with (..) convention, which is similar to relative path convention ../ but for segment

Syntax:

(.) - to match segments on the same level - ./
(..)  to match segements on one level above - ../

(..)(..) to match segements on one level above  ../../

(...)  to match segements root dir.

eg:
 (.photos)

Coding:
 We are going to create photo gallary app.

1.When navigating within the application, it is rendered as a modal
2.When the page is refreshed, it is rendered as a standalone page

G:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... route-interceptor
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\route-interceptor.


src/app/mock-data/photo.js
const photos = [
    {
        id: '1',
        name: 'Kevin Canlas',
        href: 'https://twitter.com/kvncnls/status/1471832344986324998',
        username: '@kvncnls',
        imageSrc: 'https://pbs.twimg.com/media/FGz_t1wXIAIFyT-?format=jpg',
    },
    {
        id: '2',
        name: 'Pedro Duarte',
        href: 'https://twitter.com/peduarte/status/1463897468383412231',
        username: '@peduarte',
        imageSrc: 'https://pbs.twimg.com/media/FFDOtLkWYAsWjTM?format=jpg',
    },
    {
        id: '3',
        name: 'Ahmad Awais',
        href: 'https://twitter.com/MrAhmadAwais/status/1338151679083032577',
        username: '@MrAhmadAwais',
        imageSrc: 'https://pbs.twimg.com/media/EpIR281XIAMUrEM?format=jpg',
    },
    {
        id: '4',
        name: 'Leandro Soengas',
        href: 'https://twitter.com/lsoengas/status/1352302741339693061',
        username: '@lsoengas',
        imageSrc: 'https://pbs.twimg.com/media/EsRYK8oWMAEkObV?format=jpg',
    },
    {
        id: '5',
        name: 'Samina',
        href: 'https://twitter.com/saminacodes/status/1466479548837482497',
        username: '@saminacodes',
        imageSrc: 'https://pbs.twimg.com/media/FFn7X76VgAEVTgs?format=jpg',
    },
    {
        id: '6',
        name: 'lafond.eth',
        href: 'https://twitter.com/laf0nd/status/1464640065615929346',
        username: '@laf0nd',
        imageSrc: 'https://pbs.twimg.com/media/FFNyYEAXsAMdOhV?format=jpg',
    },
    {
        id: '7',
        name: '山岸和利💛',
        href: 'https://twitter.com/ykzts/status/1426358452356407297',
        username: '@ykzts',
        imageSrc: 'https://pbs.twimg.com/media/E8txb2yVkAQxRVw?format=jpg',
    },
    {
        id: '8',
        name: 'Altngelo',
        href: 'https://twitter.com/AfterDarkAngelo/status/1456372859090075648',
        username: '@AfterDarkAngelo',
        imageSrc: 'https://pbs.twimg.com/media/FDYTZN1VIAAT-X1?format=jpg',
    },
    {
        id: '9',
        name: 'Matias Baldanza',
        href: 'https://twitter.com/matiasbaldanza/status/1404834163203715073',
        username: '@matiasbaldanza',
        imageSrc: 'https://pbs.twimg.com/media/E374pyaWEAMCT2R?format=jpg',
    },
];

export default photos;

src/app/page.js
import Link from "next/link";
import photos from "./mock-data/photo";
import Image from "next/image";


export default function Home() {
  return <main className="container mx-auto">
    <h1 className="text-center text-4xl font-bold m-10">Photo Gallary App</h1>
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 auto-rows-max gap-6 m-10">
      {/* render photos */}
      {
        photos.map(({ id, imageSrc }) => (<Link key={id} href={`/photos/${id}`}>
          <Image
            alt=""
            src={imageSrc}
            height={500}
            width={500}
            className="w-full object-cover aspect-square"
          />
        </Link>))}
    </div>
  </main>
}

src/next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
    images: {
        domains:['pbs.twimg.com']
    }
};

export default nextConfig;

Instead of display image inside same component, we can create separate Framework component.

src/app/components/Frame.jsx
import Image from "next/image"

export default function Frame({ photo }) {
    return (
        <>
            <Image alt="" src={photo.imageSrc} height={600} width={600} className="w-full object-cover aspect-square col-span-2" />
            <div className="bg-white p-4 px-6">
                <h1>{photo.name}</h1>
                <p>Taken by {photo.userName}</p>
            </div>
        </>
    )
}

Pass image as prop to the FrameComponent.

src/app/photos/[id]page.js
import Frame from "@/app/components/Frame";
import photos from "@/app/mock-data/photo";

export default function PhotoPage({ params: { id } }) {
    const photo = photos.find(p => p.id === id)
    return <div className="container mx-auto my-10">
        <Frame photo={photo} />
    </div>
}

Modal Diaglog:

Instead of showing image in the details page, we need to show in popup window, modal dialog.

src/app/components/modal.jsx
'use client'
import { useRef, useCallback, useEffect } from "react"
import { useRouter } from "next/navigation"

export default function Modal({ children }) {
    const overlay = useRef(null)
    const wrapper = useRef(null)
    const router = useRouter()
    //hooks for controlling client navigation
    const onDismiss = useCallback(() => {
        router.back()
    }, [router])

    const onClick = useCallback(
        (e) => {
            if (e.target === overlay.current || e.target === wrapper.current) {
                if (onDismiss) onDismiss()
            }
        },
        [onDismiss, overlay, wrapper]
    )
    const onKeyDown = useCallback(
        (e) => {
            if (e.key === 'Escape') onDismiss()
        },
        [onDismiss]
    )

    //useEffect  === ComponentDidUpdate
    useEffect(() => {
        document.addEventListener('keydown', onKeyDown)
        return () => document.removeEventListener('keydown', onKeyDown)
    }, [onKeyDown])
    return (
        <div
            ref={overlay}
            className="fixed z-10 left-0 right-0 top-0 bottom-0 mx-auto bg-black/60"
            onClick={onClick}
        >
            {/* This div will show the photo */}
            <div
                ref={wrapper}
                className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full sm:w-10/12 md:w-8/12 lg:w-1/2 p-6"
            >
                <h1>Modal</h1>
                {children}
            </div>
        </div>
    )

}

Create Parallel Route to display Modal;

create default.js

src/app/@modal/default.js

export default function Default(){
    return null
}

Note;
In the intercepting router,parrel route must have default.js file which must return null.

Since we have built detail page, src/app/photos/[id]/page.js,need to be converted into intercepting route

src/app/@modal/(.)photos/[id]/page.js

import photos from "@/app/mock-data/photo"
import Frame from "@/app/components/Frame"
import Modal from "@/app/components/Modal"

export default function PhotoModal({ params: { id: photoId } }) {
    const photo = photos.find((p) => p.id === photoId)

    return (
        <Modal>
            <Frame photo={photo} />
        </Modal>
    )
}
...................................................................................
				Styling - CSS,Images,Fonts
....................................................................................

Types of styling:

1.Global CSS
2.CSS Modules
3.CSS Frameworks
   ->Tail wind
   -> bootstrap
   -> SASS
4.CSS in js

:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... styling-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*

Next provides file called global.css

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

How to use css inside page or layout?

import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

Image:

 Image is component which must be used insted of html element.

     <Image
              src="/vercel.svg"
              alt="Vercel Logo"
              className="dark:invert"
              width={100}
              height={24}
              priority
            />

Fonts:
  Next provides fonts moudle which integrates google fonts which would be part of the package "next/font/google"
.................................................................................
CSS Modules:
 Component specific css

src/app/dashboard/dashboard.module.css
.dashboard {
    padding: auto;
    border: 10px;
    text-align: center;
    height:500px;
    border-color: blue;
    background-color: aquamarine;
}

src/app/dashboard/layout.js
import styles from '@/app/dashboard/dashboard.module.css'

export default function DashboardLayout({ children }) {
    return <div className={styles.dashboard}>
        {children}
    </div>
}
.....................................................................................
				 Data Fetching
.....................................................................................


Data fetching is nothing but talking to apis particular REST API or Graphql api
Next app can fetch data either from exteranl endpoints or internal endpoints, next provies feature to build rest apis.

Page can talk directly to External API.

Next Page-------------------->External API

Page can talk to Next api which intern calls external API

Next Page-------NextAPI------------>External API

Page can talk to NEXT API which talks to databases...

Types of Data Fetching:

1.Server side data fetching
2.Client side Data fetching

Server side data fetching
...........................

=>Whenever possible , we recommend fetching data on the server,This allows you to
 Have direct access to back end data resources(eg.databases)

=>Keep your application more secure by preventing sensitive information, such as access tokens and API Keys, from being exposed to the client.

=>Perform multiple data fetches with single round-trip instead of multple individual requests on the client.

=>Reduce client-server waterfalls.

=>Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.


Fetching Data Where It's Needed:

If you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally, nor forward props between components. Instead, you can use fetch or React cache in the component that needs the data without worrying about the performance implications of making multiple requests for the same data.


Parent - Layout  - apicallurl eg fetch('/api/customers')
   |
   child  - Layout -apicallsameurl -fetch('/api/customers')
     |
     child -Layout -apicallsameurl -fetch('/api/customers')
       |
      child -Layout -apicallsameurl -fetch('/api/customers')
        |
        child- Page -apicallsameurl -fetch('/api/customers')

.....................................................................................
		  Server side data fetching using "fetch" api
.....................................................................................

Fetching data on the server with fetch:
.......................................

Next.js extends the native "fetch" Web API to allow you to configure the caching and revalidating behavior for each fetch request on the server.

React extends fetch to automatically memoize fetch requests while rendering a React component tree.


There are four places You can use fetch:
1.Server components
2.Client Components
3.Route Handlers,REST API
4.Server Actions

You can use fetch with async/await in "Server Components", in "Route Handlers", and in "Server Actions".

G:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... data-fetching
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\data-fetching.
....................................................................................
			   Fetching data from external API using "fetch" api
....................................................................................

src/app/todos/layout.js
//data fetching in server component using fetch 
export async function fetchTodos() {
    console.log('layout')

    try {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        const response = await fetch(url)
        return response.json()
    }
    catch (err) {
        return err
    }

}
export default async function TodosLayout(props) {
    const todos = await fetchTodos()

    return <div>
        <h1>Total Todos {todos.length}</h1>
        {props.children}
    </div>
}

src/app/todos/page.js


//data fetching in server component using fetch 
export async function fetchTodos() {
    console.log('page')
    try {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        const response = await fetch(url)
        return response.json()
    }
    catch (err) {
        return err
    }

}

export default async function TodosPage() {
    const todos = await fetchTodos()
    return <>
        <h1>Todos Page</h1>
        <ul>
            {todos.map(todo => <li key={todo.id}>{todo.title}</li>)}
        </ul>
    </>
}
..................................................................................
			.....................................................................................
		  Server side data fetching using  "third party" api-axios
.....................................................................................

You can use any third party ajax api to call apis from next application but which is not recommended, because other apis will not have features such as caching,revalidation,request memoziation, we have to write extra code.
.....................................................................................
		     .....................................................................................
	     Data fetching in Client components-Using fetch api
....................................................................................

src/app/components/FetchPosts.jsx
'use client'

import { useEffect, useState } from "react"

export default function FetchPost() {
    const [posts, setPosts] = useState([])
    useEffect(() => {
        async function fetchPostsDetails() {
            const url = 'https://jsonplaceholder.typicode.com/posts'
            const response = await fetch(url)
            const posts = await response.json()
            setPosts((myposts) => {
                return posts.concat(myposts)
            })
        }
        fetchPostsDetails()
        return () => {
            return null
        }
    }, [])
    return <>
        <h1>Posts</h1>
        <ul>
            {posts.map(post => {
                return <li>
                    <span>{post.title}</span>
                </li>
            })}
        </ul>
    </>
}
src/app/posts/page.js

import FetchPost from "@/app/components/FetchPosts";

export default function PostPage(){
    return <div>
        <h1>Post Page Fetching Data from the Client Side</h1>
        <FetchPost/>
    </div>
}

Using fetch api in client components is not recommended, the reason which has no any caching feature is enabled, so fetch must be used only in server side.\\


.....................................................................................
How to fetch data in client comonpents?

		Data Fetching in Client Components using SWR API
....................................................................................
	
what is SWR?
 The name “SWR” is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by HTTP RFC 5861(opens in a new tab). SWR is a strategy to first return the data from cache (stale), then send the fetch request (revalidate), and finally come with the up-to-date data.


 SWR is wrapper for fetch api only.

Why SWR
1.Client side caching by default
2.Cache revalidation by default
3.You dont need to write hooks like useEffect,useState,
4.You get data,error,loading flags

src/app/components/PostsClientUsingSWR.jsx

'use client'
import useSWR from "swr"

function fetcher(...args) {
    return fetch(...args).then(res => res.json())
}

export default function FetchPostsUsingSWR() {
    const url = 'https://jsonplaceholder.typicode.com/posts'
    const { data, error, isLoading } = useSWR(url, fetcher)
    if (error) {
        return <div>
            <h1>Failed To Return</h1>
        </div>
    }
    if (isLoading) {
        return <h1>Loading...</h1>
    }
    return <ul>
        {
            data.map(post => {
                return <h2>{post.title}</h2>
            })
        }
    </ul>
}		
	
src/app/posts/page.js
import FetchPost from "@/app/components/FetchPosts";
import FetchPostsUsingSWR from "@/app/components/PostsClientUsingSWR"

export default function PostPage(){
    return <div>
        <h1>Post Page Fetching Data from the Client Side</h1>
        {/* <FetchPost/> */}
        <FetchPostsUsingSWR/>
    </div>
}
....................................................................................
		Data Fetching using Route Handler
	      (REST API Development and Integration)
....................................................................................

Next.js Provides a layer called "API" Layer in order to build REST API.

API layer can be used to write REST API which may talk to databases or external rest api or Graphql api or Microservices..

Route handler:
 Route handlers are used to CREATE API In next.js

File Name convention:
route.js

src/app/todos/
  page.js
  layout.js
  route.js - it is not recommended to write like this...


src/app/api/
  todos
     route.js
  [id]
     route.js

url pattern:
  /api/todos
  /api/customers
  /api/products

npx create-next-app@latest
√ What is your project named? ... rest-api
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\rest-api.


Inside Route Handler How to write code?

export async function HTTPVerb(request){ 

}
=>Always route function must have "export" only
=>Function must have async keyword
=>Function args must have request object

Supported Verbs:
GET
POST
PUT
PATCH
DELETE
HEAD
OPTIONS


APIS:
 NextRequest Object used to handle client request
 NextResponse Object used to send response to the client.


=>Function name must be HTTP Verb name like "GET"

routers:

src/app/api/greeter/route.js
import { NextResponse } from "next/server";

export async function GET(request) {
    //send response
    return NextResponse.json({ message: 'Hello api' })
}

Testing:
http://localhost:3000/api/greeter
.....................................................................................
			     Dynamic route 
....................................................................................

url pattern
 /api/greeter/welcome
 /api/proudcts/1


src/app/api/greeter/[message]/route.js

import { NextResponse } from "next/server";

export async function GET(request, { params: {message} }) {
    // console.log(obj.params.message)
    return NextResponse.json({ message })
}
...................................................................................
			How to read Payload- data
....................................................................................
 
Payload For 
1.Insert/save
2.Update

//POST
src/app/api/message/route.js

import { NextResponse } from "next/server";

export async function GET(request) {
    //send response
    return NextResponse.json({ message: 'Hello api' })
}
export async function POST(request) {
    //read body
    const payload = await request.json()
    console.log(payload)
    return NextResponse.json({ message: 'saved' })
}

Testing:

POST http://localhost:3000/api/greeter

{
    "message": "Hello",
    "by": "Subramanian",
    "whom": "Murugan"
}

Gudielines for writing api:

findAll
save
 /src/app/api/customers/route.js

findById
UpdatebyId
delteById
 Any api which has parameters
src/app/api/customers/[id]/route.js
.....................................................................................
			CURD Operations
.....................................................................................
1.You can  talk  to external API
2.You can talk to databses.

External API Integration
 
Next User Interface------> api layer-------->External api


src/app/api/alubms/route.js
//api layer which talks to external apis
import { NextResponse } from "next/server"

const url = 'https://jsonplaceholder.typicode.com/albums'

//Get all albums

export async function GET(request) {
    try {
        const response = await fetch(url)
        const albums = await response.json()
        return NextResponse.json(albums)
    }
    catch (err) {
        return NextResponse.json(err)
    }

}

//save

export async function POST(request) {
    try {
        const album = await request.json()
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(album)

        })
        const newAlbum = await response.json()
        return NextResponse.json(newAlbum)
    }
    catch (err) {
        return NextResponse.json(err)
    }
}

src/app/api/albums/[id]/route.js

GetById,UpdateById,DeleteByID


import { NextResponse } from "next/server"

const url = 'https://jsonplaceholder.typicode.com/albums'

//Get Album by Id
export async function GET(request, { params }) {
    try {
        const id = Number(params.id)
        const response = await fetch(`${url}/${id}`)
        const album = await response.json()
        return NextResponse.json(album)
    }
    catch (err) {
        return NextResponse.json(err)
    }
}
//update Album by Id 
export async function PUT(request, { params }) {
    //read payload,id
    try {
        const { title } = await request.json()
        const id = Number(params.id)
        const res = await fetch(`${url}/${id}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ title })
        })
        const updatedAlbum = await res.json()
        return NextResponse.json(updatedAlbum)
    }
    catch (err) {
        return NextResponse.json(err)
    }
}

//Delete Album by Id 

export async function DELETE(request, { params }) {

    try {
        const id = Number(params.id)
        const response = await fetch(`${url}/${id}`, {
            method: 'DELETE'
        })
        const album = await response.json()
        return NextResponse.json(album)
    }
    catch (err) {
        return NextResponse.json(err)
    }

}
.....................................................................................					Configuration
.....................................................................................

In the above example, we haved coded urls, what if i dont want to hard code.

const url = 'https://jsonplaceholder.typicode.com/albums'

How to externalize the data like urls?

We have file called '.env' file.

Environment variables:

 Next js comes with built in support for env variables which allows you to make your app more configurable, more flexiable.

File syntax:

.env
.env.environment

enviromnent would be "dev or prod or test"

eg:
.env
.env.development
.env.production
.env.test
.env.local

Loading Enviromental Variables:

Next js has built in support for loading environment variables from ".env" or ".env.local" into process.env

projectRootDir/.env

ALBUMS_URL="https://jsonplaceholder.typicode.com/"


src/app/api/alumbs/route.js

import { NextResponse } from "next/server"

// const url = 'https://jsonplaceholder.typicode.com/albums'
const url = `${process.env.ALBUMS_URL}/albums`

//Get Album by Id
export async function GET(request, { params }) {
    try {
        const id = Number(params.id)
        const response = await fetch(`${url}/${id}`)
        const album = await response.json()
        return NextResponse.json(album)
    }
    catch (err) {
        return NextResponse.json(err)
    }
}
//update Album by Id 
export async function PUT(request, { params }) {
    //read payload,id
    try {
        const { title } = await request.json()
        const id = Number(params.id)
        const res = await fetch(`${url}/${id}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ title })
        })
        const updatedAlbum = await res.json()
        return NextResponse.json(updatedAlbum)
    }
    catch (err) {
        return NextResponse.json(err)
    }
}

//Delete Album by Id 

export async function DELETE(request, { params }) {

    try {
        const id = Number(params.id)
        const response = await fetch(`${url}/${id}`, {
            method: 'DELETE'
        })
        const album = await response.json()
        return NextResponse.json(album)
    }
    catch (err) {
        return NextResponse.json(err)
    }

}
....................................................................................
		API Integration with Pages(User Interface)
....................................................................................
src/app/albums/page.js

export async function getAlbums() {
    const url = `${process.env.HOST}/alubums`
    //const url = 'http://localhost:3000/api/alubums'
    // console.log(url)
    const response = await fetch(url)
    return response.json()
}

export default async function AlbumPage() {
    const albums = await getAlbums()
    return <>
        <h1>AlbumPage</h1>
        <ul>
            {
                albums.map(album => {
                    return <li key={album.id}>{album.title}</li>
                })
            }
        </ul>
    </>
}
Assigment:
 Build Master details page using route handlers(rest api)
.....................................................................................
                              Database Integration
....................................................................................
Next js can integrate with any data base including sql (mysql,oracle,postgresql) and no sql (mongo,neodb,redis)

In order to talk to databases application uses database drivers and apis....

Mostly we use using databse frameworks called "ORM- Object Relational Mapping" Framework..

For Node js, We have many frameworks...

1.Prisma
2.Sequalize
3.Type ORM
etc...

Step 1:

G:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... rest-dbapp
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\rest-dbapp.


Step 2: Install Prisma Framework

Before installing prisma framework, we have to decide what database we are going to use.
If you are going to use postgre sql database, then postgresql database must have been installed.

How to install database?  any database

1.download database like postgres
2.install locally

In modern days, we never download database and install, then how to download and install.

Via container technologies like "Docker".

Now i am going to use "inMemory"  database we dont even need docker....

Note:
 In memory databases not for production, or not for real time apps, only for learning purpose...

In Memory Databases:
1.sqllite.
2.H2
etc...

we are going to use sqlite database...

Any database we need to install database dirvers for prisma.

3.Install sqlite database dirver.

G:\IBM\2024\March\Nextjs\rest-dbapp>npx prisma init --datasource-provider sqlite
Need to install the following packages:
prisma@5.10.2
Ok to proceed? (y) y

✔ Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

warn You already have a .gitignore file. Don't forget to add `.env` in it to not commit any private information.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Run npx prisma db pull to turn your database schema into a Prisma schema.
3. Run npx prisma generate to generate the Prisma Client. You can then start querying your database.

More information in our documentation:
https://pris.ly/d/getting-started

After installing, you can find folder inside project

projectRootDir/prisma

prisma folder contians a file called "schema.prisma"

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

Env variable was created automatically ".env"

projectRootDir/.env
# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

DATABASE_URL="file:./dev.db"
....................................................................................
			  ORM Fundamentals
....................................................................................
What is orm?
Object Relational Mapping
 |         |       |
Entity RDBMS    Binding

In Database programs, we sql sql quires for creating,inserting, updating, deleting

In ORM World, SQL Quries are abstracted by apis like save, findAll, findById, remove,update..

Entity Represents a "table" in the database.

Schema :
  The plan or structure

Define Model (Enity)

model User {

}
model Product {

}

Fields:
 Fields are mapped in the table as columns

model Comment{
 id Int @id @default(autoincrement())
 title String
 content String
}

id -  column Name(field)
Int - Datatype
@id - Primiary Key
@default - what is value we are going to assign to primary key
autoincrement - function which generates values...


Where to define this model?

prisma/schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// We have to define model

model User {
  id        String   @id @default(uuid())
  name      String
  email     String
  role      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
,,,,,,,,,,,,,,,,,,,,............................................................,
		   Map model in the database
...................................................................................
1.Creating tables in the database

G:\IBM\2024\March\Nextjs\rest-dbapp>npx prisma migrate dev --name init
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

Applying migration `20240311072557_init`

The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20240311072557_init/
    └─ migration.sql

Your database is now in sync with your schema.

Running generate... (Use --skip-generate to skip the generators)

added 6 packages, and audited 144 packages in 11s

34 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

added 1 package, and audited 145 packages in 7s

34 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

✔ Generated Prisma Client (v5.10.2) to .\node_modules\@prisma\client in 53ms


AFter running this step, you can see the table structure


migrations/
  └─ 20240311072557_init/
    └─ migration.sql
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "role" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
			  Seeding Database
.....................................................................................

This step is only for testing, which is optional in production apps.

While app starts if you want to insert some data for testing, you seed database


prisma/seed.mjs
import { PrismaClient } from "@prisma/client";

//Prisma client is object through which we can seed database
const prisma = new PrismaClient();

async function main() {
    //variable.modelname.api
    const user = await prisma.user.create({
        data: {
            name: 'admin',
            email: 'admin@ibm.com',
            role: 'admin'
        }
    })
    console.log('created', user)
}
main().then(() => prisma.$disconnect()).catch(async (e) => {
    console.log(e)
    await prisma.$disconnect()
    process.exit()
})

package.json
{
  "name": "rest-dbapp",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "prisma": {
    "seed" : "node prisma/seed.mjs"
  },
  "dependencies": {
    "@prisma/client": "^5.10.2",
    "next": "14.1.3",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "autoprefixer": "^10.0.1",
    "postcss": "^8",
    "prisma": "^5.10.2",
    "tailwindcss": "^3.3.0"
  }
}

Seeding:
 G:\IBM\2024\March\Nextjs\rest-dbapp>npx prisma db seed
Environment variables loaded from .env
Running seed command `node prisma/seed.mjs` ...
created {
  id: 'ec923d4e-a7cd-478d-bd63-bb92518faf83',
  name: 'admin',
  email: 'admin@ibm.com',
  role: 'admin',
  createdAt: 2024-03-12T04:21:46.996Z,
  updatedAt: 2024-03-12T04:21:46.996Z
}

The seed command has been executed.
.....................................................................................
				Prisma Client Api
.....................................................................................

Prisma client api offers methods to talk to database... it offers curd api...

src/lib/prisma.js
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global

export const  prisma = globalForPrisma.prisma || new PrismaClient({ log: ["query"] })
.....................................................................................
			 Rest api with Prisma
.....................................................................................

src/app/api/users/route.js
import { prisma } from "@/lib/prisma";
import { NextResponse } from "next/server";

//findAll Users
export async function GET() {
    try {
        const users = await prisma.user.findMany()
        if (!users) {
            return NextResponse.json({ message: 'No Users Found', code: 404 })
        } else {
            return NextResponse.json(users)
        }
    }
    catch (err) {
        return new NextResponse(err.message, { status: 500 })
    }
}
//create new User
export async function POST(request) {
    try {
        const json = await request.json()
        const user = await prisma.user.create({
            data: json
        })
        return new NextResponse(JSON.stringify(user), {
            status: 201, headers: {
                "Content-Type": "application/json"
            }
        })
    }
    catch (err) {
        return new NextResponse(err.message, { status: 500 })
    }
}

src/app/users/[id]/route.js
import { prisma } from "@/lib/prisma";
import { NextResponse } from "next/server";

//findAll Users
export async function GET(request, { params }) {
    try {
        const id = params.id
        const users = await prisma.user.findUnique({
            where: {
                id
            }
        })
        if (!users) {
            return NextResponse.json({ message: 'No Users Found', code: 404 })
        } else {
            return NextResponse.json(users)
        }
    }
    catch (err) {
        return new NextResponse(err.message, { status: 500 })
    }
}

//update operation
export async function PUT(request, { params }) {
    try {
        const id = params.id
        const user = await request.json()
        const updatedUser = await prisma.user.update({
            where: { id },
            data: user
        })
        if (!updatedUser) {
            return NextResponse.json({ message: `No User found with ID ${id}`, code: 404 })

        }
        return NextResponse.json(updatedUser)
    }
    catch (err) {
        return new NextResponse(err.message, { status: 500 })
    }

}

// delete a record

export async function DELETE(request, { params }) {

    try {
        const id = params.id
        if (!id) {
            return NextResponse.json({ message: `No User found with ID ${id}`, code: 404 })

        } else {
            await prisma.user.delete({
                where: {
                    id
                }
            })
            return new NextResponse(null, { status: 204 })

        }
    }
    catch (err) {

    }
}
/////////////////////////////////////////////////////////////////////////////////////
		 Database Integration with User Interface(Pages)
.....................................................................................


src/app/users/page.js


export async function getUsers() {
    const url = `${process.env.HOST}/users`
    const response = await fetch(url)
    return response.json()
}

export default async function UserPage() {
    const users = await getUsers()
    return <main className="flex  flex-col justify-between p-24">
        <h1>User Page</h1>
        <ul>
            {
                users.map(user => {
                    return <li key={user.id}>
                        <span>{user.name}</span>-<span>{user.id}</span>
                    </li>
                })
            }
        </ul>
    </main>
}

Assigment:
You have to build detail page
You have to delete a record
....................................................................................
			  SSG-Static Site Generation
.....................................................................................

if page uses Static Generation, the page html is generated at "build time".
When you run next build, during that time, pages are generated.
Generated HTML will be then reused on each request. It can be cached by CDN.

You can statically generate pages "with or with out data"

:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... ssg-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\ssg-app.


Static Generation Without Data:
...............................
By default, Next.js Pre-render pages using "SSG" without fetching data 

src/app/about/page.js
export default function About() {
    return <div>About</div>
}
Note that this page does not need to fetch any external data to be pre-rendered..
In this case, next generates a single HTML File per page during build time.

How to generate?

npm run build

G:\IBM\2024\March\Nextjs\ssg-app>npm run build

> ssg-app@0.1.0 build
> next build

   ▲ Next.js 14.1.3

   Creating an optimized production build ...
 ✓ Compiled successfully
 ✓ Linting and checking validity of types
 ✓ Collecting page data
 ✓ Generating static pages (6/6)
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (app)                              Size     First Load JS
┌ ○ /                                    5.22 kB        89.5 kB
├ ○ /_not-found                          882 B          85.1 kB
└ ○ /about                               137 B          84.4 kB
+ First Load JS shared by all            84.3 kB
  ├ chunks/69-c292296505fe2927.js        29 kB
  ├ chunks/fd9d1056-c7082c319cc53ced.js  53.4 kB
  └ other shared chunks (total)          1.87 kB


○  (Static)  prerendered as static content

 This command prepares the app  for production, it generates html pages during build phase...

After building you can the app using

npm start

.................................................................................

Static Generation with data:
...........................

Some pages require fetching external data for "pre-rendering"

There are two scenarios, and one or both might apply...

Function:

The "generateStaticParams" function can be used in coimbation with dynamic route segements to define the list of route segment parameters that will be statically generated at build time instead of on-demand at request time.

How to build ssg app?

=>You have to override the function called "generateStaticParams"
=>This function to be called during build time...

Steps:

1.Create Master Page..

src/app/todos/page.js
import Link from "next/link"

export async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    return response.json()
}

export default async function TodosMasterPage() {
    const todos = await fetchTodos()
    return <div>
        <h1>Total Todos {todos.length}</h1>
        <ul>
            {
                todos.map(todo => {
                    return <>
                        <li>
                            <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                        </li>
                    </>
                })
            }
        </ul>
    </div>
}

2.Create Details Page

Override generateStaticParams method
export async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    return response.json()
}
export async function fetchTodosById(id) {
    const url = `https://jsonplaceholder.typicode.com/todos/${id}`
    const response = await fetch(url)
    return response.json()
}
export default async function TodosDetailPage(props) {
    const todo = await fetchTodosById(Number(props.params.id))
    return <>
        <h2>id {todo.id}</h2>
        <p> title {todo.title}</p>
        <p> Status {todo.completed ? '✔' : '🚩'}</p>
    </>
}

//override function which is called during build time in order to prepare the page...

export async function generateStaticParams() {

    const todos = await fetchTodos();
    //generate html pages for all todos , if you have 200 records, 200 html files would be generated
    return todos.map(todo => {
        //based on id only the pages are generated, id value must be string always
        let id = todo.id.toString()
        return {
            id: id
        }

    })
}

This function must return alway array..

We can build the page..


npm run build
G:\IBM\2024\March\Nextjs\ssg-app>npm run build

> ssg-app@0.1.0 build
> next build

   ▲ Next.js 14.1.3

   Creating an optimized production build ...
 ✓ Compiled successfully
 ✓ Linting and checking validity of types
 ✓ Collecting page data
 ✓ Generating static pages (207/207)
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (app)                              Size     First Load JS
┌ ○ /                                    5.22 kB        89.5 kB
├ ○ /_not-found                          882 B          85.1 kB
├ ○ /about                               140 B          84.4 kB
├ ○ /todos                               6.96 kB        91.2 kB
└ ● /todos/[id]                          140 B          84.4 kB
    ├ /todos/1
    ├ /todos/2
    ├ /todos/3
    └ [+197 more paths]
+ First Load JS shared by all            84.3 kB
  ├ chunks/69-c292296505fe2927.js        29 kB
  ├ chunks/fd9d1056-c7082c319cc53ced.js  53.4 kB
  └ other shared chunks (total)          1.87 kB


○  (Static)  prerendered as static content
●  (SSG)     prerendered as static HTML (uses getStaticProps)


You can look at project workspace, there is ".next" folder would have been created.

This folder having all production files

.next/server/app/todos/
    1.html
    2.html
    3.html
    200.html

How to test?

npm start

....................................................................................
				Dynamic Segements and SSG


Single Dynamic Segment:

export function generateStaticParams(){
   return [
	{id:'1' },{id:'2'},{id:'3'},{id:'4'}
  ]
}
export default function Page({params}){
   const {id} = params
}
Url Pattern
/product/1
/product/2

Mulitple Dynamic Segment:

export function generateStaticParams(){
   return [
	{id:'1' ,category:'a' },{id:'2',category:'b'},{id:'3',category:'c'},{id:'4',category:'d'}
  ]
}

export default function Page({params}){
   const {id,category} = params
}

eg:

src/app/products/[category]/[product]/page.js
// /products/a/1
export async function generateStaticParams() {
    return [
        {
            category: 'a', product: '1'
        },
        {
            category: 'b', product: '2'
        },
        {
            category: 'c', product: '3'
        },
        {
            category: 'd', product: '4'
        }
    ]
}
export default function Page({ params }) {
    const { category, product } = params

    return <>
        <h1>category {category}  Product {product}</h1>
    </>
}

G:\IBM\2024\March\Nextjs\ssg-app>npm run build

> ssg-app@0.1.0 build
> next build

   ▲ Next.js 14.1.3

   Creating an optimized production build ...
 ✓ Compiled successfully
 ✓ Linting and checking validity of types
 ✓ Collecting page data
 ✓ Generating static pages (212/212)
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (app)                              Size     First Load JS
┌ ○ /                                    5.22 kB        89.5 kB
├ ○ /_not-found                          882 B          85.1 kB
├ ○ /about                               152 B          84.4 kB
├ ○ /products                            152 B          84.4 kB
├ λ /products/[category]                 152 B          84.4 kB
├ ● /products/[category]/[product]       152 B          84.4 kB
├   ├ /products/a/1
├   ├ /products/b/2
├   ├ /products/c/3
├   └ /products/d/4
├ ○ /todos                               6.96 kB        91.2 kB
└ ● /todos/[id]                          152 B          84.4 kB
    ├ /todos/1
    ├ /todos/2
    ├ /todos/3
    └ [+197 more paths]
+ First Load JS shared by all            84.3 kB
  ├ chunks/69-c292296505fe2927.js        29 kB
  ├ chunks/fd9d1056-c7082c319cc53ced.js  53.4 kB
  └ other shared chunks (total)          1.87 kB


○  (Static)   prerendered as static content
●  (SSG)      prerendered as static HTML (uses getStaticProps)
λ  (Dynamic)  server-rendered on demand using Node.js

npm start
.....................................................................................
			Catch-All Dynamic Segment
...................................................................................

app/products/[...slug]/page.js

export async function generateStaticParams() {
    return [
        { slug: ['a', '1'] },
        { slug: ['b', '2'] },
        { slug: ['c', '3'] }

    ]
}
export default function Page({ params }) {
    const { slug } = params
     console.log(slug)
    return <>
        {slug}
    </>
}
.....................................................................................
			 Loading UI and Streaming
.....................................................................................
Loading UI:
  The special file called "loading.js" helps to creating meaningfull loading ui with "React Suspense"

G:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... loading-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\loading-app.

src/app/dashboard/layout.js
export default function DashBoardLayout(props) {

    return <>
        {props.children}
    </>
}
src/app/components/greeter.jsx

export default function Greeter() {
    return <h1>Hello</h1>
}
src/app/loading.js
export default function Loading() {
    return <span>⏳</span>
}

src/app/page.js
import React from "react"

const Welcome = React.lazy(() => {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 8000, import('./components/greeter'))
    })
})

export default function DashBoardPage() {
    return <>
        <Welcome/>
    </>
}

Component Structure;

<Layout>
	<Suspense fallback={<Loading/>}>
	    <Page/>
	</Suspense>
</Layout>
.....................................................................................
	 Putting loading status with in Page: Over riding existing loading.js
.....................................................................................

Can we add loader via suspense manually.

Yes!, we can add, always local suspense takes priority.


src/app/dashboard/page.js
import React, { Suspense } from "react"

const Welcome = React.lazy(() => {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 8000, import('./components/greeter'))
    })
})

export default function DashBoardPage() {

    // return <>
    //     <Welcome/>
    // </>
    return <>
        <h1>DashBoard Page</h1>
        {/* <Welcome/> */}
        <Suspense fallback={<h1>Loading⛳</h1>}>
            <Welcome/>
        </Suspense>
        <h1>Something else</h1>
        <h1>Something else</h1>
        <h1>Something else</h1>
        <h1>Something else</h1>
        <h1>Something else</h1>
        <h1>Something else</h1>

    </>
}
.....................................................................................
			 Streaming
.....................................................................................

What is Streaming?
Before understanding what is streaming,we need to understand how SSR works and its limitation.

Streaming is going to improve performance of SSR Limitations.

Steps Involved In SSR:
.....................

1.First , all data for a given page is fetched on the server.

2.The server then renders the HTML page 

3.Once the HTML is ready, the server will send HTML,CSS,javascript for the page are sent to the client.

4.NonInteractive user interface is shown using the generated HTML and CSS In browser

5.Finally React, Hydrates,the user interface to make it interactive


How to measure web site performance?

In order to measure web performance we have some metrics

1.TTFB
2.FCP
3.TTI

TTFB: Time to First Byte:
........................
 Time to First Byte (TTFB) refers to the time between the browser requesting a page and when it receives the first byte of information from the server. This time includes DNS lookup and establishing the connection using a TCP handshake and SSL handshake if the request is made over HTTPS

TTFB is a metric that measures the time between the request for a resource and when the first byte of a response begins to arrive.


FCP :First Contentfull Paint
............................
The First Contentful Paint (FCP) metric measures the time from when the page starts loading to when any part of the page's content is rendered on the screen


TTI:Time to Interactive 

  Time to Interactive (TTI) is a non-standardized web performance 'progress' metric defined as the point in time when the last Long Task finished and was followed by 5 seconds of network and main thread inactivity.

These steps are sequentinal and blocking, meaning that the server only render HTML for a page once all the data has been fetched. 
And on the client side React can only hydrate the UI once the code for all components in the page has been downloaded..

this is traditional process, which degrades the app loading performance

.....................................................................................
		  How to improve loading performance
....................................................................................

SSR with React and Next.js helps improve the perceived loading performance by showing a non interactive page to the user as soon as possible.

Only HTML can be sent once the data fetching is over.


Streaming allows you to break down the page's HTML into smaller chunks and progressively send those chunks from the server to the client.

This enables part of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered.


How to break down into chunks?

  React mental model is component driven, each component we can treat as chunk.

eg:
  if a component have priority or that dont rely on data can be sent first (eg layouts),so the react can hydration eariler....
 if components has less priority, or depends data to be sent later...

How to implement streaming?
 You have to split code into segments

1.static code which does not depend on data
2.dynamic code which depends on data.

if you wrap any component with "Suspense Boundary" which is async, can be rendered later.

if the component relays on data fetching, delays with timers, delays with network connections......

Streaming Component:
....................

export default function Product(props) { 
   <section>
    <nav><a href="product.html"><a></nav>
    <Suspense fallback={<h1>loading....}>
	 <ProductDetails/>
     <Suspense>
   <section>
	
}

Through suspense we can enable streaming....

1.Streaming server rendering: Progressively rendering html from the server to the client

2.Selective Hydration 
    React prioritizes what components to make interactive first based on user interaction.
.....................................................................................
			  Error Handling
...................................................................................
There are two types of errors

1.Page error
 if route is not found, then it throws NotFound page
 not-found.js

2.Application error.
  error.js

Handling Errors:
	JavaScript errors inside components used to corrupt React’s internal state and cause it to emit cryptic errors on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.

Introducing Error Boundaries
A JavaScript error in a part of the UI shouldn’t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an “error boundary”


Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.

 Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // You can also log the error to an error reporting service
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children; 
  }
}

<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
.....................................................................................
			     Error Boundaries and Next js
.....................................................................................

The error.js file is convention which allows to handle runtime errors in nested routes..

The error.js is having fallback ui incase of error happened..

The error.js represents  React ErrorBoundary

app
 |
 page.js
 layout.js
 dashboard
    |
    page.js
    layout.js
    error.js


error.js
 It automatically creates ReactErrorBoundary that wraps a nested child segment or page compoent
  <Layout>
  
    <ErrorBoundary fallback={<Error/>}
	<Layout>
		<Page/>
        </Layout>
    </ErrorBoundary>
  </Layout>
..................................................................
error components are "client components" -  error.js must be client component


G:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... error-handler
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\error-handler.


src/app/dashboard/error.js

'use client'
import { useEffect } from "react"

//Error Component must be client Component


export default function Error({ error, reset }) {
    //log error
    useEffect(() => {
        //write logic to report error. you can error report to error reporting tools
        console.log(error)
    }, [error])

    return <>
        {/* Fallback ui incase error happened */}
        <div>
             <h1>Something went wrong!</h1>
             <button onClick={()=>{
                reset()
             }}>Try</button>
        </div>
    </>

}

Component Hiearchy:

<Layout>
   <ErrorBoundary fallback=<Error/>
	<Page/>
   </ErrorBoundary>
</Layout>

How to enable error handler?

src/app/dashboard/page.js
export default function DashboardPage() {

    const isvalid = true
    if (isvalid) {
        console.log('error')
        throw 'Dashboard Page is broken'
    }

    return <>
        <h1>Dashboard Page</h1>
    </>
}
.....................................................................................
				SEO - Meta data
.....................................................................................

Next js has meta data API that can be used to define your application meta data eg meta and link tags inside HTML element for improved SEO and web sharability.

There are two ways you define meta data to your application.

1.config based meta data
   Export a static meta data via object called "Meta Data Object"
   Dynamic meta data is nothing but getting data from the api and use that data for   SEO, we can get dynamic meta data via "generateMetaData" Function

2.File based meta data
  Add static or dynamically generated special files to route segements.

 "With both these options, Next js will automatically generate the relevant <head>   
  elements for your pages.

1.Config based Meta data:
..........................

src/app/layout.js

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

src/app/posts/page.js

//add meta data
export const metadata = {
    title: 'Post'
}


export default function Posts() {
    return <>
        <h1>Post</h1>
    </>
}
.....................................................................................
			 Dynamic Meta Data
.....................................................................................

src/app/posts/[id]/page.js


//dynamic meta daa

export async function generateMetadata({ params, searchParams }, parent) {
    const id = Number(params.id)
    const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`)
    const post = await response.json()
    //return meta object 

    return {
        title: `${post.id} detail`
    }
}

export default async function Posts(props) {
    return <div className="flex min-h-screen flex-col  justify-between p-24">
        <h1>{props.params.id}</h1>
    </div>
}
.....................................................................................
			  Caching,Revalidation,ISR
....................................................................................	

What is caching?

 Caching means we dont need to call method more number of times if that method return same value.

Normal function execution
function add(a,b){
   console.log('add is called')
   return a + b
}

add(1,1)
add(1,1)
add(1,1)
add(1,1)
add(1,1)

here function takes same input, returns same output,but it is called evertime...
This approach degrades app performance, instead the returned value can be saved in memory or some other place, with same arg , if method called, we dont need to invoke again and again, rather returns result from the memory or some place which is called cache.

Request Memoization:

if "fetch" function is called in single tree  with same url for same data no of times
that means if you call in the layout, again if call in nested call, again in page , inside page  with in generateMetadata, generateStaticParams... fetch call is cached in the layout itself..

<layout> - fetch('/someapi') - called and cached
  |
  <page> - fetch('/someapi') - will take from cache, no api call is made against 			     server
   |
   generateMetadata -fetch('/someapi') -will take from cache, no api call is made 					against server

   |
   generateStaticParams-fetch('/someapi') -will take from cache, no api call is made 					against server


   -Render completed - cache is reset.


  "React extends the fetch API to automatically memoize requests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once."


What if i want to use other than fetch api, like axios?

 you can use axios, but i lacks memoziation , that means that api is not cached by default.

 if want caching with axios, "react cache"

 const cachedFn = cache(fn);

.....................................................................................
			   Caching,Revalidation,ISR
.....................................................................................

How to enable and disable cache? and How to revalidate?


G:\IBM\2024\March\Nextjs>npx create-next-app@latest
√ What is your project named? ... caching-isr
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2024\March\Nextjs\caching-isr.


In order to test how caching works , we are going to use api which returns current date and time , so that we can easily understand how caching is working..

https://worldtimeapi.org/api/timezone/Asia/Kolkata

src/app/timecache/[city]/page.js


export default async function CachePage(props) {
    //with caching
    const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Kolkata')
    const data = await response.json()

    return <>
        <h1>Time Now: {new Date(data.datetime).toLocaleTimeString()}</h1>
    </>
}

Testing:
http://localhost:3000/timecache/Kolkata

You can notice the time has not changed, because data has been cached by default.


Without Cache: When cache is disabled



export default async function CachePage(props) {
    //with caching
    const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Kolkata', { cache: 'no-store' })
    const data = await response.json()

    return <>
        <h1>Time Now: {new Date(data.datetime).toLocaleTimeString()}</h1>
    </>
}

Testing:
http://localhost:3000/timecache/Kolkata

You can notice the time changed.
.....................................................................................
			Caching and Revalidation (clear the cache)

How to revalidate the cache?

1.Time based revalidation
2.OnDemand revalidation
   ->Tag based
   ->Path based

You can mix all revalidation in single route segment...


Time based Revalidation:
Configuration can be provided

1.As part of fetch call
2.As part of route segment config object


1.As part of fetch call
export default async function CachePage(props) {
    //with caching
    const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Kolkata', { next: { revalidate: 2 } })
    const data = await response.json()

    return <>
        <h1>Time Now: {new Date(data.datetime).toLocaleTimeString()}</h1>
    </>
}

2.As part of route segment config object

//route segment config for revalidation
export const revalidate = 2

export default async function CachePage(props) {
    //with caching
    // const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Kolkata', { next: { revalidate: 2 } })

    const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Kolkata')

    const data = await response.json()

    return <>
        <h1>Time Now: {new Date(data.datetime).toLocaleTimeString()}</h1>
    </>
}

....................................................................................
				
OnDemand Revalidation:
.......................
 OnDemand revalidation is done via api call, when you call api, validation triggers..

Steps:

1.You have to write rest api, which revalidates cache
  1..1. You can path
  1..2. You can use tag


path Based validation
src/app/api/revalidate/route.js
import { revalidatePath } from "next/cache"
import { NextResponse } from "next/server"


export  async function GET(request) {
    //get the path so that we can revalidate via path 
    const path = request.nextUrl.searchParams.get('path') || '/timecache/Kolkata'
    revalidatePath(path)
    console.log('revalidated', path)
    return NextResponse.json({ revalidated: true, now: Date.now(), cache: 'no-store' })

}

Tag Based Revalidation:
.......................

Steps: 
1.We have to add tag in fetch call
export default async function CachePage(props) {
    const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Kolkata', {
        next: {
            tags: ['collection']
        }
    })
    const data = await response.json()

    return <>
        <h1>Time Now: {new Date(data.datetime).toLocaleTimeString()}</h1>
    </>
}


2.We have to get tag in api, based on that we have to revalidate.

import { revalidateTag } from "next/cache"
import { NextResponse } from "next/server"


export async function GET(request) {
    //get Tag//Collection 
    const collection = request.nextUrl.searchParams.get('collection') || 'collection'
    revalidateTag(collection)
    console.log('revalidated', collection)
    return NextResponse.json({ revalidated: true, now: Date.now(), cache: 'no-store' })

}
....................................................................................
			    ISR - Incremental Static Rendering
.....................................................................................

ISR =  SSG + Caching + Revalidation.

SSG:
  -> Get data during build process 
  -> Render page and cache it 
  
Revalidation
  ->When we want fresh data for the page
  ->during revalidation, cache is cleared, so that the page also need to be re    rendered

"Incremental Static Rendering is nothing but create pages during build time and cache it,if any data change for the particular page, re render that page, after cleaning the cache either by using time based or on demand or both"

ISR = >SSR + SSR = Static Rendering + Dynamic Rendering === Build time +request time

How to implment ISR?

1.Enable Cache
2.Select Revalidation pattern
3.override generateStaticParams method  where you have generate page , after build   time, the page is cached
4.Revaildate the pre build page, using revalidation pattern so that page is rebuilt.

During SSG, the pages are cached by default.

Once the app gone to the production, after that if you want  rebuild page you can apply revalidation process.

ISR = SSG + Revalidation



export default async function CachePage(props) {
    const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/Kolkata', {
        next: {
            tags: ['collection']
        }
    })
    const data = await response.json()

    return <>
        <h1>Time Now: {new Date(data.datetime).toLocaleTimeString()}</h1>
    </>
}
//SSG 
export async function generateStaticParams() {
    return [
        {
            city: 'Kolkata'
        }
    ]
}
Testing 
YOu can select any revalidation pattern (time, or ondemand)

next run build

G:\IBM\2024\March\Nextjs\caching-isr>npm run build

> caching-isr@0.1.0 build
> next build

   ▲ Next.js 14.1.3

   Creating an optimized production build ...
 ✓ Compiled successfully
 ✓ Linting and checking validity of types
 ✓ Collecting page data
 ✓ Generating static pages (7/7)
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (app)                              Size     First Load JS
┌ ○ /                                    5.22 kB        89.5 kB
├ ○ /_not-found                          882 B          85.1 kB
├ λ /api/revalidate                      0 B                0 B
└ ● /timecache/[city]                    137 B          84.4 kB
    └ /timecache/Kolkata
+ First Load JS shared by all            84.3 kB
  ├ chunks/69-c292296505fe2927.js        29 kB
  ├ chunks/fd9d1056-c7082c319cc53ced.js  53.4 kB
  └ other shared chunks (total)          1.87 kB


○  (Static)   prerendered as static content
●  (SSG)      prerendered as static HTML (uses getStaticProps)
λ  (Dynamic)  server-rendered on demand using Node.js


npm start


http://localhost:3000/timecache/Kolkata

http://localhost:3000/api/revalidate
.....................................................................................



